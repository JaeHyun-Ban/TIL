# 6. 자료구조


## 1) malloc과 포인터 복습
### 들어가기 전에
C로 구현할 수 있는 다양한 데이터 구조를 배우게 됩니다.
데이터 구조를 정의하고 관리하는데 있어서 메모리와 포인터에 대한 개념을 정확히 이해하는 것이 중요합니다. 지난 시간에 배운 malloc함수와 포인터를 복습할 수 있는 작은 예제를 살펴보자

### 학습 목표
- 포인터의 개념과 malloc함수의 용법을 잘 이해할 수 있습니다.

### 핵심 단어
- 포인터
- malloc

```
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
```
위의 코드는 main함수 안에 x와 y의 포인터를 선언하고
x는 malloc함수를 이용해서 int자료형 크기의 메모리를 할당해준다

그리고 x와 y의 포인터에 각각 값을 저장하게 되는데
포인터 x는 메모리가 할당되어있어 가르키는 곳이 존재하지만
포인터 y는 단지 값만 할당할 뿐 가르키는 곳이 존재하고 있지않다

따라서 초기화 되지 않은 포인터y로 인해 오류가 발생할 수 있다.

오류를 해결하기 위해서
```
y = x;

*y = 13;
```
```y = x;```코드를 대입해 y는 x가 가르키는 곳과 동일한 곳을 가르키게 함으로써 문제를 해결하고, *y에 13을 대입하면 코드는 위에서 아래로 진행됨에 따라 두 곳이 가르키는 곳은 결국 13으로 저장되게 될 것이다. 

### 생각해보기
포인터를 초기화시키지 않고 값을 저장하면 어떤 오류가 발생할 수 있을까요?
- 초기화되지 않음은 즉 포인터가 가리키고 있는곳이 존재하지 않다는 뜻이다.
    - 메모리를 지정해 가르키고있는 곳이 없이 값을 넣게 된다면 어디에도 위치하지않은 쓰레기 값으로 메모리상에 존재하게 될 것이다.


=====================================================================
## 2) 배열의 크기 조정하기
### 들어가기 전에
컴퓨터 안의 메모리는 마치 사물함과 같은 구조이다. 우리가 사용하고자 하는 사물함의 개수를 한 번 정한 이후에는, 공간이 모자란다고 해서 주변의 사물함을 마음대로 더 사용할 수는 없다. 이미 다른 목적으로 사용되고 있을 수 있기 때문이다. 이와 같이 이미 일정한 크기의 메모리가 할당되어 있는 상황에서, 그 크기를 늘리는 일은 생각보다 단순하지 않은데 **포인터와 malloc**의 개념을 응용해, 이미 정의된 배열의 크기를 바꿔보도록 해보자

### 학습 목표
배열의 크기를 조정하는 코드를 작성해보자

### 핵심 단어
- malloc
- **realloc(메모리를 새로 할당)**

일정한 크기의 배열이 주어졌을 때, 그 크기를 키우려면 어떻게 해야 할까?
단순히 현재 배열이 저장되어 있는 메모리 위치의 바로 옆에 메모리를 덧붙이면 되겠지만, 실제로는 다른 데이터가 저장되어 있을 확률이 높다. 따라서 안전하게 **새로운 공간에 큰 크기의 메모리를 다시 할당하고** 기존 배열의 값들을 하나씩 옮겨줘야 한다. 따라서 이런 작업은 O(n), 즉 배열의 크기 n만큼의 실행 시간이 소요될 것이다. 
```
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //int 자료형 3개로 이루어진 list 라는 포인터를 선언하고 메모리 할당
    int *list = malloc(3 * sizeof(int));

    // 포인터가 잘 선언되었는지 확인
    if (list == NULL)
    {
        return 1;
    }

    // list 배열의 각 인덱스에 값 저장
    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    //int 자료형 4개 크기의 tmp 라는 포인터를 선언하고 메모리 할당
    int *tmp = malloc(4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    // list의 값을 tmp로 복사
    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }

    // tmp배열의 네 번째 값도 저장
    tmp[3] = 4;

    // list의 메모리를 초기화
    free(list);

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 배열 list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    // list의 메모리 초기화
    free(list);
}
```
### realloc 이용한 코드
```
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```

### 생각해보기
이미 할당된 메모리의 크기를 조절할 때 임시 메모리를 새로 할당해줘야 하는 이유는 무엇인가요?
- 이미 할당된 메모리의 다음칸에는 다른 데이터로 메모리공간이 채워져 있을 수 있기때문에 문제가 생길 수 있다. 따라서 새로운 공간에 메모리를 할당해 통째로 옮겨주는 것이 안전하기 때문이다


=====================================================================
## 3) 연결리스트: 도입
### 들어가기 전에
우리는 여러 자료형의 데이터를 메모리 상에 저장하고 읽고 삭제하는 방법을 배웠습니다. 컴퓨터 프로그램은 이러한 데이터를 이용해서 다양한 작업을 수행할 수 있습니다. 하지만 좀 더 복잡한 프로그램을 구현하다 보면 기본적으로 포인터 구조만 이용해서 메모리를 관리하기에는 다소 번거로울 때가 많다. 만약 메모리를 좀 더 효율적으로 관리하고 사용할 수 있다면 어떨까?
데이터 구조의 개념과 연결리스트에 대해 배워보자

### 학습 목표
연결 리스트의 정의를 설명할 수 있습니다.

### 핵심 단어
- 연결 리스트(linked list)

---

### 연결 리스트(Linked list)
**데이터 구조**는 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체 입니다. 일종의 메모리 레이아웃, 또는 지도라고 생각할 수 있다. 

**배열**에서는 각 인덱스의 값이 메모리상에서 연이어 저장되어 있다. 하지만 꼭 그럴필요가 있을까?
각 값이 메모리상의 여러군데 나뉘어져 있다고 하더라고 **바로 다음 값의 메모리 주소만 기억하고 있다면** 값을 연이어서 읽어들일 수 있다.
이를 ```연결리스트```라고 한다. 

### 연결리스트의 구조체 정의
```
typedef struct node
{
    int number;
    struct node *next;
}
node;
```
node라는 이름의 구조체는 number와 *next 두 개의 필드가 함께 정의되어 있다.
number는 각 node가 가지는 값, *next는 다음 node를 가리키는 포인터가 된다.
여기서 typedef struct 대신 typedef struct node라고 ```node```를 함께 명시해 주는 것은, 구조체 안에서 node를 사용하기 위함이다.


### 생각해보기
연결 리스트를 배열과 비교했을 때 장단점은 무엇이 있을까요?
- 배열에 비해 데이터의 주소값이 항상 함께 붙어있지 않아도 괜찮아서 좀더 동적으로 사용가능하다


=====================================================================
## 4) 연결 리스트: 코딩
### 들어가기 전에
연결 리스트의 정의와 리스트의 기본 다누이가 되는 구조체를 정의하는 방법을 배운것을 토대로 실제로 연결 리스트를 구현하고 사용해보자

### 학습 목표
연결 리스트를 구현하고 사용할 수 있다

### 핵심 단어
- 연결 리스트(Linked List)

---
```
#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
    int number; 

    //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫 번째 node를 가리킬 것입니다. 
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킵니다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미입니다. 
    // 즉, n이 가리키는 node의 number 필드를 의미하는 것입니다. 
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
    n->next = NULL;

    // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
    list = n;

    // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장합니다.
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node입니다. 
    //이 node의 다음 node를 n 포인터로 지정합니다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다. 
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다. 
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 됩니다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}
```


### 생각해보기
연결 리스트의 중간에 node를 추가하거나 삭제하는 코드는 어떻게 작성할 수 있을까요?


---
연결되지 않은 노드들을 ```빵부스러기```라고 표현한 것이 아주 인상깊었다.

=====================================================================
## 5) 연결리스트: 시연
### 들어가기 전에
직접 연결리스트를 시연해 보고 연결 리스트와 배열을 비교해 장단점을 생각해 보자

### 학습 목표
- 연결 리스트와 배열의 장단점을 설명하자

### 핵심 단어
- 연결 리스트
- 배열

---
배열과 비교해서 ```연결 리스트```는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다는 장점이 있습니다.
하지만 이런 유동적인 구조는 그 대가가 따릅니다. 구조가 정적인 배열과 달리 연결 리스트에서 임의 접근이 불가능합니다.

연결 리스트에 값을 추가하거나 검색하는 경우를 생각해 봅시다.
이를 위해서는 해당하는 위치까지 연결 리스트의 각 node들을 따라 이동해야 합니다
따라서 연결 리스트의 크기가 n 일때 그 실행 시간은 ```O(n)```이 된다.

배열의 경우 임의 접근이 가능하기 때문에 (정렬이 되어 있는 경우) 이진 검색을 이용하면 O(log n)의 실행 시간이 소요되는 것에 비해 다소 불리합니다.

이처럼 여러 데이터 구조는 각각 장단점이 존재합니다.
프로그래밍을 할 목적에 부합하는 가장 효율적인 데이터 구조를 고민해서 사용하는 것이 중요합니다.

### 생각해보기
배열이 정렬되어 있지 않은 경우의 검색 소요 시간을 연결 리스트의 검색 시간과 비교해보세요.
- 배열이 정렬되어있지 않다면 배열안의 값들을 하나씩 검사해 나아가야 하기 때문에 O(n)이고,
연결 리스트는 만들어진 구조상 포인터로 가르키는 것을 쭉 따라가야 하기 때문에 필연적으로 O(n)이 나오게 된다

=====================================================================
## 6) 연결 리스트: 트리

### 들어가기 전에
연결 리스트를 활용해서 보다 더 다양한 데이터 구조를 만들 수 있습니다. 연결 리스트에서 각 요소가 
다른 요소를 하나씩만 가리키고 있었습니다. 만약 가리키는 요소가 여러개가 된다면 어떤 장점과 단점이 있을까요?
```트리```라는 연결리스트 기반의 자료구조를 통해 알아보자


### 학습 목표
트리의 구조를 설명하고 활용하는 코드를 작성할 수 있다.

### 핵심 단어
- 트리
- 루트

---
트리는 연결리스트를 기반으로 한 새로운 데이터 구조입니다.
연결리스트에서는 각 노드(node)들의 연결이 1차원적으로 구성되어 있다면,
트리에서의 노드들의 연결은 2차원적으로 구성되어 있다고 볼 수 있습니다.
각 노드는 일정한 층에 속하고, 다음 층의 노드들을 가리키는 포인터를 가지게 된다.

트리는 나무가 거꾸로 뒤집혀 있는 형태를 생각하면 된다.
가장 높은 층에서 트리가 시작되는 노드를 ```루트```라고 한다.
루트 노드는 다음 층의 노드들을 가리키고 있고, 이를 ```자식 노드```라고 한다.

이진 검색 트리를 알아보자
각 노드가 구성되어 있는 구조를 살펴보면 일정한 규칙을 알 수 있다.
먼저 **하나의 노드는 두 개의 자식 노드를 가진다.**
또 **왼쪽 자식 노드는 자신의 값보다 작고**, **오른쪽 자식노드는 자신의 값보다 큽니다.**
따라서 이런 트리 구조는 이진 검색을 수행하는데 유리합니다.


```
//이진 검색 트리의 노드 구조체
typedef struct node
{
    // 노드의 값
    int number;

    // 왼쪽 자식 노드
    struct node *left;
 
   // 오른쪽 자식 노드
    struct node *right;
} node;

// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}
이진 검색 트리를 활용하였을 때 검색 실행 시간과 노드 삽입 시간은 모두 O(log n) 입니다.
```

### 생각해보기
값을 검색할 때 이진 검색 트리가 기본 연결 리스트에 비해 가지는 장점과 단점은 무엇이 있을까요?
- 단순히 직진해서 탐색하는 작업을 절반으로 나눠서 탐색을 하기 떄문에 시간을 효과적으로 단축 할 수 있다.
하지만 그만큼의 메모리가 더 늘어난다


 

=====================================================================
## 7) 해시 테이블

### 들어가기 전에
연결리스트나 트리에서는 값을 검색할 때 O(n) 또는 O(log n)의 시간이 걸렸습니다
이 시간을 조금 더 단축해서 거의 O(1)에 가깝게 할 수는 없을까?
이를 가능하게 해주는 **해시 테이블**이라는 자료 구조에 대해 알아보자

### 학습 목표
- 해시 테이블의 원리와 구조를 설명

### 핵심 단어
- 해시 테이블
- 해시 함수
---
해시 테이블은```연결 리스트의 배열```입니다. 
여려 값들을 몇개의 바구니에 나눠 담는 상황을 생각해 봅시다.
각 값들은 ```해시 함수```라는 맞춤형 함수를 통해서 어떤 바구니에 담기는 지가 결정 됩니다.
각 바구니에 담기는 값들은 그 바구니에서 새롭게 정의도는 연결 리스트로 이어집니다.
이와 같이 연결 리스트가 담긴 바구니가 여러개 있는 것이```연결 리스트의 배열```, 즉 ```해시 테이블```이 됩니다.

쉬운 예로 사람의 이름이 해시 테이블에 저장될 때, 해시 함수는 ```이름의 가장 첫 글자```인 경우를 생각해서
알파벳 개수에 해당하는 총 26개의 포인터들이 있을 것이며, 각 포인터는 그 알파벳을 시작으로 하는 이름들을 저장하는 연결 리스트를 가리키게 된다.

만약 해시 함수가 이상적이라면, 각 바구니에는  단 하나의 값들만 담기게 될 것 입니다.
따라서 검색 시간은 ```O(1)``이 됩니다.
하지만 그렇지 않은 경우, 최악의 상황에는 단 하나의 바구니에 모든 값들이 담겨서 ```O(n)```이 될 수도 있습니다.
일반적으로는 최대한 많은 바구니를 만드는 해시 함수를 사용하기 때문에 거의 O(1)에 가깝다고 볼 수 있습니다.

### 생각해보기
해시 함수는 어떻게 만들 수 있을까요?
- 알파벳의 갯수 26개에 아스키 코드 번호를 대입해주고 
각 이름이 들어올 때마다 0번째 글자를 아스키코드 숫자로 변환
조건문을 통해 해당 번호와 일치하는 곳에 연결 리스트 방식으로 쭉 쌓아준다

---
### 후기
모두를 구분할 수 있는 각각 바구니에 넣어준다면 속도는 아주아주 빠를 것이다
단, 메모리가 엄청 많이 들겟지만


=====================================================================
## 8) 트라이

### 들어가기 전에 
문자열의 길이가 일정한 경우 이 문자열들을 저장하고 관리하는데 최적의 자료 구조는 무엇이며,
연결 리스트, 트리, 또는 해시 테이블이 최선의 방안이 될 수 있을까?
```트라이```라는 자료구조에 대해 알아보자

### 학습 목표
트라이의 원리와 구조를 설명할 수 있습니다.

### 핵심 단어
- 트라이

---
```트라이```는 기본적으로 ```트리```형태의 자료 구조입니다.
특이한 점은 **각 노드가 배열**로 이루어져 있다는 것이다.

예를 들어 영어 알파벳으로 이루어진 문자열 값을 저장한다고 한다면 
이 노드는 a부터 z까지의 값을 가지는 배열이 됩니다.
그리고 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)를 가리킨다.
이름이 들어오면 노드로 한 글짜식 구분해가며 트리의 구조처럼 점점 아래로 내려가게 된다

따라서 트라이에서 값을 검색하는데 걸리는 시간은 ```문자열의 길이```에 의해 한정된다.
단순히 문자열의 각 문자를 보며 트리를 탐색해 나가기만 하면 되니까.
일반적인 영어 이름의 길이를 n이라고 했을 때, 검색 시간은 **O(n)**이 되지만,
대부분의 이름은 그리 크지 않은 **상수값**(예. 20자 이내)이기 때문에 O(1)이나 마찬가지라고 볼 수 있습니다.

### 생각해보기
트라이가 해시 테이블에 비해 가지는 장점과 단점은 무엇일까요?
- 더 세분하게 나누어서 동일한 이름이 아닌 이상 더 빠르고 쉽게 구분해서 찾을 수 있게 된다.
하지만 결국 좋은 기능을 사용하기 위해서는 그에 맞는 많은 양의 메모리가 필요하게 될 것이다.
---  
좋은기능을 쓰기 위해서 많은 노드를 만들 수록 많은 양의 메모리를 사용하게 되는 것이다
(자원을 효율적으로 사용해야 하는 이유)

=====================================================================
## 9) 스택, 큐, 딕셔너리

### 들어가기 전에
간단하지만 많이 쓰이는 데이터 구조 세 가지를 더 살펴보자
메모리의 구조에서 잠깐 살펴보았던 ```스택```과```큐```, 그리고 해시테이블로 구현할 수 있는 ```딕셔너리``에 대해 알아보자

### 학습 목표
스택, 큐, 딕셔너리의 원리와 구조를 설명할 수 있다.

### 핵심 단어
- 스택
- 큐
- 딕셔너리

---
### 큐
큐는 메모리 구조적으로 값이 아래로 쌓이는 구조이다.
값을 넣고 뺄 때```선입 선출``` 또는 ```FIFO```라는 방식을 따르게 된다.
가장 먼저 들어온 값이 가장 먼저 나간다는 뜻이다.
은행에서 줄을 설 때 가장 먼저 줄을 선 사람이 가장 먼저 업무를 처리하게 되는 것과 동일하다.
**배열**이나 **연결 리스트**를 통해 구현 가능하다

### 스택
반면 스택은 메모리 구조적으로 값이 위로 쌓이는 구조이다.
따라서 값을 넣고 뺄 때 ```후입 선출```또는 ```LIFO```라는 방식을 따르게 된다.
가장 나중에 들어온 값이 가장 먼저 나가는 것이다.
뷔페에서 접시를 쌓아 둘 때 사람들이 가장 위에 있는 **(가장 나중에 쌓인)** 접시를 가장 먼저 들고 가는 것과 동일하다.
역시 **배열**이나 **연결 리스트**를 통해 구현 가능하다.

### 딕셔너리
딕셔너리는 ```키```의 ```값```이라는 요소로 이루어져 있다.
```키```에 해당하는 ```값```을 저장하고 읽어오는 것이다.
마치 대학교에서 **학번**에 따라서 **학생**이 결정되는 것과 동일하다.
일반적인 의미에서 **해시 테이블**과 동일한 개념이라고도 볼 수 있다.
역시 ```키```를 어떻게 정의할 것인지가 중요하다.

### 생각해보기
여태까지 배운 개념들을 기반으로 해서 나만의 새로운 자료 구조를 만들어 볼 수 있을까요?






=====================================================================

=====================================================================
