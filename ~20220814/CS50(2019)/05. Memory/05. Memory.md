# 5.메모리

### 목표
1. 16진법을 읽고 쓸 수 있다
2. 메모리 주소에 접근하고 값을 받아오는 코드를 C로 작성할 수 있다.

## 1) 메모리 주소
C로 작성한 변수들은 실제로 컴퓨터 메모리에 어떻게 저장될까요?
메모리 주소를 나타내는 방법과 그 주소를 알아내는 방법, 주소에 찾아가는 방법을 배워보자

### 16진수의 표현법
- 0 1 2 3 4 5 6 7 8 9 A B C D E F
    - 영어로 뒤의 6자리를 사용한다

### RGB의 표현
- 00 00 00
- FF0000
    - FF(R255)00(G0)00(B0)
- 16진수의 표시법으로 값을 조절한다

### 16진수의 표시법
- 0x0. 0x1. 0x2, 0x3....0x1F
    - 앞에 **0x**를 붙여준다
    - 10진수와 햇갈리지 않으려고 사용한다
    - 10진수를 2진수로 변환 후 4자리씩(16진수) 끊어서 표현해 준다

```
#include<stdio.h>

int main(void)
{
	int n = 50;
	printf("%p\n", &n); 
    
    //&~ : ~의 주소값을 가져온다
    //*~: ~의 주소로 이동한다.(goto)
    //%p: 주소값을 받는 형식 지정자, 항상 16진수를 출력한다
    
    printf("%i\n", *&n);
    
}
```

### 생각해보기
'CS50'을 16진수로 표현해볼까요?
1. 아스키 코드로 변환
- c = 67 / s = 83 / 50 
- 67 = 0100 0011 / 83 = 0101 0011 / 50 = 0011 0010
- 0x43 / 0x53 / 0x32


====================================================================================
## 2) 포인터
메모리 주소를 직접 관리하기는 쉽지 않을 수 있다
C에는 포인터라는 개념을 통해 변수의 주소를 쉽게 저장하고, 접근할 수 있게 해준다
포인터가 무엇인지, 어떻게 사용하는지 알아보자.

```
#include<stdio.h>

int main(void)
{
	int n = 50;
    //변수에 주소를 저장하고 싶다면 변수명에 *를 붙여줘야 한다
	int *p = &n; // n의 주소값을 저장

    //p에 저장된 값을 출력하려면 어떻게 해야 할까
    
    printf("%p\n", p); //*p의 주소값을 출력한다
    printf("%i\n", *p); //*p주소값이 가르키는 변수의 값을 출력한다

}
```

====================================================================================
## 3) 문자열
문자열 string 자료형은 실제로 C에서 존재하지 않습니다
문자열이 실제로 메모리상에 어떻게 존재되어 있는지, 
문자열을 손쉡게 저장하고 접근하기 위한 방법을 배워보자.


### 문자열의 저장방식
%s 형식 지정자는 사실 포인터이다
EMMA\0로 메모리에 저장되어있으며, %s는 E를 가르키고있다
그리고 \0을 확인해서 그 전까지 출력하고 있다.
```
String s = "EMMA";
char *s = "EMMA";

//string은 이렇게 생성해 놓고 우리가 사용하고 있는 것이다.
typedef char *string; 
```
```
#include<stdio.h>

int main(void)
{
	// string s = "EMMA";
    char *s = "EMMA";

    printf("%p\n", s);
    //EMMA에서 E의 주소만 구하는법
    printf("%p\n", &s[0]);
    //C에서 S의 주소는 사실상 문자열의 첫번째 문자의 주소이다.
    
    printf("%p\n", &s[1]);
    printf("%p\n", &s[2]);
    printf("%p\n", &s[3]);
    //>각 주소는 1바이트씩 차이가 난다.

}
```

====================================================================================
## 4) 문자열 비교
1. 두 문자열이 같은 내용을 담고 있는지 어떻게 비교할 수 있을까?
2. 문자열 자료형을 사용해 바로 직접적으로 비교가 가능할 까?
문자열이 저장되어 있는 방식을 자세히 들여다보면서 알아보자

### 문자열의 비교방법
- a,b 두개의 변수에 같은 문자열을 저장을한다
    - 문자열은 다른 메모리공간(주소)에 저장하게 된다
    - a,b의 문자열을 서로 비교 할 때 포인터가 가르키는 곳을 비교하게 되고
    따라서 두개의 변수는 같지 않다는 결론이 나오게 된다.

```
#include<stdio.h>

int main(void)
{
    char *s = "EMMA";

    printf("%c\n", *s); //첫번째 문자 출력 = E
    
    // printf("%c\n", *s[1]);이 아래처럼 바뀌어서 컴파일 된다.
    printf("%c\n", *(s+1)); //두번째 문자 출력 = M
    printf("%c\n", *(s+2));
    printf("%c\n", *(s+3));

}
```

====================================================================================
## 5) 문자열 복사
이미 저장되어 있는 문자열을 다른곳에 복사하려면 어떻게 해야할까?

### 핵심 단어
1. malloc

```
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```
s라는 변수에는 "emma"의 **첫번째 메모리 주소**가 저장되기 때문에 t에 저장해봣자 제대로 실행되지 않는다


```
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```
malloc함수를 이용해 t를 정의하고 + 1 을 통해 \n(널 종단 문자)까지 대비해서 생성해 줍니다
그리고 변수 n에 문자열길이를 구해주는 값을 저장해 매번 for 실행시 마다 값을 쓸데없이 구하는 계산을 방지해 준다. n에 \n을 계산해서 + 1을 반복 구간으로 생성해준다.

---
### 생각해보기
배운 바와 같이 메모리 할당을 통해 문자열을 복사하지 않고, 단순히 문자열의 주소만 복사했을 때는 어떤 문제가 생길까요?
- 문자열의 주소를 복사해서 사용한다면 복사한 문자열변수에 값이 변경 시 가르키고 있는 주소의 원래 문자열까지 변경이 될 것 입니다.


====================================================================================
## 6) 메모리 할당과 해제
메모리를 할당해 저장한 값이 필요없어지고 나면 어떻게 해야할까?
유한한 메모리를 효과적으로 관리하기 위해서 프로그램을 작성하며 할당한 많은 메모리들은 어떻게 관리해야 하는지 알아보자

### 핵심 단어
1. free
2. valgrind

---
malloc함수를 이용해 메모리를 할당한 후에는 free라는 함수를 이용해 메모리를 해제해 주어야 한다
그렇지 않게 되면 메모리에 저장한 값은 **쓰레기 값**으로 남게되어 메모리 용량을 낭비하게 된다
이를 **"메모리 누수"**라고 한다

**valgrind**라는 프로그램으로 우리가 작성한 코드에 **메모리 관련된 문제**가 있는지 쉽게 확인할 수 있다
```help50 valgrind ./filename```와 같은 명령어로 사용하자

```
#include <stdlib.h>

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
```
위와같은 명령어가 있을 때
int형 변수 x 에 40바이트를 할당한다 그러면 
x[0] ~ x[9] 까지 총 10개가 저장된다
그리고 위의 코드를 valgrind로 검사해보면 오버플로우와 메모리 누수 두 가지 에러를 확인할 수 있다.
- **x[10]은 할당해 주지 않은 크기로 overflow(오버플로우)를 발생시킨다**
- **malloc으로 메모리를 할당 후 free(x)를 통해 할당 메모리를 해제하지않아서 메모리 누수를 발생시킨다**

### 생각해보기
제한된 메모리를 가지고 프로그래밍을 할 때 메모리를 해제하지 않으면 어떤 문제가 발생할 수 있을까요?

- 해제되지 않은 메모리는 제한된 양을 점점 차지하게 될 것이고 정말 사용해야할 상황에 메모리를 사용하지 못하게 될 것이다.

====================================================================================
## 7) 메모리 교환, 스택, 힙
콜라와 사이다가 들어있는 두개의 컵이 있고, 콜라와 사이다를 각각 다른 컵으로 바꿔 담고 싶으면 어떻게 해야할까?
교환을 도와줄 새로운 컵이 잠시 필요할 것이다.
그렇다면 메모리에 저장된 값들을 교환할 때도 비슷하게 이용할수 있는지 알아보자

### 핵심 단어
1. 스택
2. 힙
3. 포인터


```
noswap.c
-------------------
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}


```
위 코드를 사용해 보면 swap은 제대로 작동하지 않게되는데
사실 swap함수는 교환을 제대로 하는것이 아닌 x와 y의 값을 복제하여 서로 다른 메모리 주소에 저장해서 사용하는 것이다.

- 데이터는 저장되는 구역이 나뉘어져 있다. **malloc으로 할당된 메모리는 hip영역에 데이터가 저장**된다 그리고 **stack에는 프로그램 내의 함수와 관련된 것들이 저장**된다.
- 이를 바탕으로 다시 생각해보면, 위의 코드에서 a,b,x,y,tmp는 모두 **stack영역**에 저장되어 있지만 main함수와는 서로 다른위치에 저장된 변수인 것이다.
- 그래서 swap에서 위치를 변경해도 아무런 영향을 미치지 않는것이다.

```힙영역은 위에서 아래로 늘어난다```, ```스택영역은 아래에서 위로 쌓여간다```
```main은 스택영역에있으며 사용자정의 함수는 그 위에 존재한다```

- 이를 포인터로 주소를 알려줘서 위치를 변경할 수 있도록 한다
```
swap.c
-------------------
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```
swap에 a와b의 주소값을 보내 포인터로 저장해 사용해서 변경해주면
실제 main의 x,y의 값을 변경해 줄 수 있다

### 생각해보기
메모리 영역을 다양하게 나누는 이유는 무엇일까요?
- 저장영역을 나눠서 사용함으로써 한 공간에 전부 다 넣어서 비효율적으로 사용하는 일을 방지하기 위해서 인것 같다. 
- 우리가 평소에 폴더를 정리할 때 나눠서 정리하는것과 마찬가지인 것 같다.



====================================================================================
## 8) 파일 쓰기
사용자에게 입력을 받는 함수는 어떻게 구현되어 있을까?
앞서 배운 메모리교환, 스택의 정의를 복습 후 두 함수를 직접 구현해 보고, 더 나아가서 파일에 출력해보는 방법도 알아보자

### 목표
- 사용자로부터 값을 입력받아 파일에 출력하는 프로그램을 작성할 수 있습니다.

### 핵심 단어
1. scanf
2. fopen
3. fprintf
4. fclose
---
힙 영역에서 malloc에 의해 메모리가 더 할당될수록 사용하는 메모리가 아래로 늘어나는데 점점늘어나 제한된 메모리 용량을 초과하는 현산을 **힙 오버플로우**, **스택 오버플로우**라고 말한다.
### scanf
- 변수를 입력받아 변수에 넣어준다
```
#include <stdio.h>

int main(void)
{
    int x;
    printf("x: ");
    scanf("%i", &x);
    printf("x: %i\n", x);
}
-------------------------------------------
#include <stdio.h>

int main(void)
{
    char s[5];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}
```
- int변수는 &를 사용해 그 주소에 값을 입력해 넣어준다
- char변수는 크기를 배열로 지정해 준뒤 그 주소에 값을 입력해 준다
    - \0값까지 생각해서 입력하고 싶은 글자 + 1로 계산해주자

```
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *file = fopen("phonebook.csv", "a");
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");
    fprintf(file, "%s,%s\n", name, number);
    fclose(file);
}
```
### fopen("파일이름", (r,w,a))
- r: read
- w: write
- a: append(덧붙이기)
fopen은 해당 파일을 가르키는 포인터다.


### fprintf
- 파일을 출력해주는 명령어
    -  fprintf(file, "%s,%s\n", name, number);
```aaa.csv``` csv파일은 ```,```로 인덱스를 분리해서 저장해준다

### fclose
작업이 끝난 후에는 fclose함수로 파일에 대한 작업을 종료해 줘야한다.

---
### 생각해보기
get_long, get_float, get_char도 비슷한 방식으로 직접 구현할 수 있을까요?

====================================================================================
## 9) 파일 읽기
일상적으로 사용하는 파일은 텍스트, 이미지, 영상 등 여러 형식이 있다
JPEG형식의 파일인 경우 그 값속에는 JPEG파일 형식인지를 알려주는 실마리가 있다
파일을 읽고 그 실마리를 찾아보자

### 학습 목표
파일을 읽고 JPEG 파일인지를 검사하는 프로그램을 작성할 수 있습니다.

### 핵심 단어
1. JPEG
2. fread
---
파일의 내용을 읽어서 파일의 형식이 JPEG이미지인지를 검사하는 프로그램을 알아보자
```
#include <stdio.h>

int main(int argc, char *argv[])
{
    //실행코드 + 실행파일 = argc 2(파일 1개만 실행해라)
    if (argc != 2)
    {
        return 1;
    }

    //읽은 파일(argv[1])을 r(읽기)형태로 불러옴
    FILE *file = fopen(argv[1], "r");

    //파일이 비어있을때
    if (file == NULL)
    {
        return 1;
    }
 
   unsigned char bytes[3];
    fread(bytes, 3, 1, file);

    //JPEG형식의 파일들이 생성될 때 정의한 약속들(바이트가 0xFF, 0xD8, 0xFF)이 들어있는지 확인
    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
    fclose(file);
}
```
























